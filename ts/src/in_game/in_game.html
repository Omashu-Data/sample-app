<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../../css/variables.css" />
  <link rel="stylesheet" href="../../css/metrics.css" />
  <link rel="stylesheet" href="../../css/overview.css" />
  <link rel="stylesheet" href="../../css/events.css" />
  <title>Omashu.gg - In-Game</title>
  <link rel="stylesheet" href="../../css/in-game.css" />
</head>
<body class="in-game">
  <!-- Div para capturar y procesar eventos del juego - NO MODIFICAR LA ESTRUCTURA -->
  <div id="logs" style="display: none;">
    <div id="events" class="logColumn">
      <div id="eventsLog" class="dataText"></div>
    </div>
    <div id="infoUpdates" class="logColumn">
      <div id="infoLog" class="dataText"></div>
    </div>
  </div>

  <div id="app-container" class="app-container">
    <!-- Header - Fijo en la parte superior, 740px x 44px -->
    <div id="header-container" class="header-container"></div>
    
    <!-- Banner Horizontal - Debajo del header, 740px x 90px -->
    <div id="banner-horizontal-container" class="banner-horizontal-container"></div>
    
    <!-- Tabs - Debajo del banner horizontal, 740px x 42px -->
    <div id="tabs-menu-container" class="tabs-menu-container"></div>
    
    <!-- Contenedor principal que contiene el contenido de las tabs y el banner vertical -->
    <div class="main-content-wrapper">
      <!-- Contenido de las pestañas - A la izquierda, 580px de ancho -->
      <div class="tabs__content">
        <!-- Contenedores vacíos para las pestañas, el contenido se cargará dinámicamente -->
        <div id="overview-tab" class="tabs__pane tabs__pane--active">
          <!-- El contenido se cargará desde tab-overview.html -->
          <div class="loading-indicator">Cargando resumen de jugador...</div>
        </div>
                  
        <div id="stats-tab" class="tabs__pane">
          <!-- El contenido se cargará desde tab-stats.html -->
          <div class="loading-indicator">Cargando estadísticas...</div>
        </div>
                  
        <div id="events-tab" class="tabs__pane">
          <!-- El contenido se cargará desde tab-events.html -->
          <div class="loading-indicator">Cargando eventos...</div>
        </div>
                  
        <div id="clips-tab" class="tabs__pane">
          <!-- El contenido se cargará desde tab-clips.html -->
          <div class="loading-indicator">Cargando clips...</div>
        </div>
                  
        <div id="performance-tab" class="tabs__pane">
          <!-- El contenido se cargará desde tab-performance.html -->
          <div class="loading-indicator">Cargando análisis de rendimiento...</div>
        </div>
                  
        <div id="upgrade-tab" class="tabs__pane">
          <!-- El contenido se cargará desde tab-upgrade.html -->
          <div class="loading-indicator">Cargando opciones de mejora...</div>
        </div>
                  
        <div id="heatmap-tab" class="tabs__pane">
          <!-- El contenido se cargará desde tab-heatmap.html -->
          <div class="loading-indicator">Cargando mapa de calor...</div>
        </div>
      </div>
            
      <!-- Banner Vertical - A la derecha, 160px x 600px -->
      <div id="banner-vertical-container" class="banner-vertical-container"></div>
    </div>
  </div>
            
  <!-- Scripts -->
  <script src="../../scripts/libs/jquery.min.js"></script>
  <script src="../../js/in_game.js"></script>
  <script src="header-loader.js"></script>
  <script src="components-loader.js"></script>

  <!-- SISTEMA INTEGRADO DE CAPTURA DE EVENTOS Y GESTIÓN DE DATOS -->
  <script>
    // ---- GESTOR CENTRALIZADO DE DATOS DEL JUEGO ----
    const gameDataManager = {
      currentData: {
        summoner: {
          name: '',
          champion: '',
          level: 0,
          team: '',
          position: '',
          role: ''
        },
        match: {
          gameMode: '',
          gameTime: 0,
          kills: 0,
          deaths: 0,
          assists: 0,
          cs: 0,
          gold: 0,
          totalDamageDealt: 0,
          totalDamageToChampions: 0,
          visionScore: 0
        },
        combat: {
          damageDealt: 0,
          damageTaken: 0,
          magicDamageDealt: 0,
          physicalDamageDealt: 0,
          trueDamageDealt: 0,
          largestCriticalStrike: 0,
          healingDone: 0
        },
        objectives: {
          turretKills: 0,
          baronKills: 0,
          dragonKills: 0,
          wardPlaced: 0,
          wardKilled: 0
        },
        events: []
      },
      
      listeners: [],
      
      updateData: function(newData) {
        console.log('gameDataManager.updateData llamado con:', 
          JSON.stringify({
            summoner: newData.summoner ? newData.summoner.name : 'no disponible',
            gameTime: newData.match ? newData.match.gameTime : 'no disponible',
            kda: newData.match ? `${newData.match.kills}/${newData.match.deaths}/${newData.match.assists}` : 'no disponible'
          })
        );
        
        if (newData.summoner) {
          Object.assign(this.currentData.summoner, newData.summoner);
        }
        if (newData.match) {
          Object.assign(this.currentData.match, newData.match);
        }
        if (newData.combat) {
          Object.assign(this.currentData.combat, newData.combat);
        }
        if (newData.objectives) {
          Object.assign(this.currentData.objectives, newData.objectives);
        }
        if (newData.events && newData.events.length > 0) {
          this.currentData.events = this.currentData.events.concat(newData.events);
          if (this.currentData.events.length > 100) {
            this.currentData.events = this.currentData.events.slice(-100);
          }
        }
        
        this.notifyListeners();
        
        // NUEVO: Mostrar un marcador visible para depurar
        this.showDataMarker();
      },
      
      subscribe: function(callback) {
        console.log('gameDataManager.subscribe llamado');
        if (typeof callback === 'function' && !this.listeners.includes(callback)) {
          this.listeners.push(callback);
          console.log(`Nuevo listener añadido. Total: ${this.listeners.length}`);
          callback(this.currentData);
        }
        return this;
      },
      
      unsubscribe: function(callback) {
        const index = this.listeners.indexOf(callback);
        if (index !== -1) {
          this.listeners.splice(index, 1);
        }
        return this;
      },
      
      notifyListeners: function() {
        console.log(`Notificando a ${this.listeners.length} listeners con datos:`, 
          JSON.stringify({
            summoner: this.currentData.summoner.name,
            gameTime: this.currentData.match.gameTime,
            kda: `${this.currentData.match.kills}/${this.currentData.match.deaths}/${this.currentData.match.assists}`
          })
        );
        
        this.listeners.forEach(callback => {
          try {
            callback(this.currentData);
          } catch (e) {
            console.error('Error en listener de datos:', e);
          }
        });
      },
      
      getData: function() {
        return JSON.parse(JSON.stringify(this.currentData));
      },
      
      // NUEVO: Método para mostrar un marcador visual de actualización de datos
      showDataMarker: function() {
        // Crear o actualizar un marcador visual para debugging
        let marker = document.getElementById('data-update-marker');
        if (!marker) {
          marker = document.createElement('div');
          marker.id = 'data-update-marker';
          marker.style.position = 'fixed';
          marker.style.bottom = '10px';
          marker.style.right = '10px';
          marker.style.background = 'rgba(0, 128, 0, 0.7)';
          marker.style.color = 'white';
          marker.style.padding = '5px 10px';
          marker.style.borderRadius = '5px';
          marker.style.fontSize = '12px';
          marker.style.zIndex = '9999';
          document.body.appendChild(marker);
        }
        
        marker.textContent = `Datos actualizados: ${new Date().toLocaleTimeString()} - ${this.currentData.summoner.name} (${this.currentData.match.kills}/${this.currentData.match.deaths}/${this.currentData.match.assists})`;
        
        // Efecto de parpadeo
        marker.style.animation = 'none';
        marker.offsetHeight; // Forzar reflow
        marker.style.animation = 'blink 0.5s';
      }
    };
    
    // Crear estilos para la animación de parpadeo
    const style = document.createElement('style');
    style.textContent = `
      @keyframes blink {
        0% { opacity: 0.3; }
        50% { opacity: 1; }
        100% { opacity: 0.3; }
      }
    `;
    document.head.appendChild(style);
    
    // ---- SISTEMA DE CAPTURA DE EVENTOS DE LOL ----
    
    // Lista de características que necesitamos capturar
    const features = [
      'gep_internal',
      'live_client_data',
      'matchState',
      'match_info',
      'death',
      'respawn',
      'abilities',
      'kill',
      'assist',
      'gold',
      'minions',
      'summoner_info',
      'gameMode',
      'teams',
      'level',
      'announcer',
      'counters',
      'damage',
      'heal',
      'items',
      'ward',
      'vision',
      'objective',
      'spell_cast'
    ];
    
    // Elementos DOM para logs
    const eventsLog = document.getElementById('eventsLog');
    const infoLog = document.getElementById('infoLog');
    
    // Función para añadir a los logs
    function addToLog(logElement, data, highlight = false) {
      if (!logElement) return;
      
      const pre = document.createElement('pre');
      pre.textContent = JSON.stringify(data, null, 2);
      
      if (highlight) {
        pre.className = 'highlight';
      }
      
      logElement.appendChild(pre);
      logElement.scrollTop = logElement.scrollHeight;
      
      // Limitar el número de logs
      while (logElement.childElementCount > 50) {
        logElement.removeChild(logElement.firstChild);
      }
    }
    
    // Formatear tiempo de juego
    function formatGameTime(timeInSeconds) {
      const minutes = Math.floor(timeInSeconds / 60);
      const seconds = timeInSeconds % 60;
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Exponer globalmente para que las pestañas puedan usarlo
    window.formatGameTime = formatGameTime;
    
    // ---- MANEJADORES DE EVENTOS DE OVERWOLF ----
    
    // Manejar errores
    function onError(info) {
      console.error("Error:", info);
      addToLog(eventsLog, { type: 'error', info: info }, true);
    }
    
    // Manejar actualizaciones de información
    function onInfoUpdates(info) {
      addToLog(infoLog, info);
      console.log("Recibida actualización de info:", info);
      
      try {
        const updates = {
          summoner: {},
          match: {},
          combat: {},
          vision: {},
          objectives: {},
          events: []
        };
        
        // Actualizar datos del invocador
        if (info.summoner_info) {
          if (info.summoner_info.name) {
            updates.summoner.name = info.summoner_info.name;
          }
          if (info.summoner_info.champion) {
            updates.summoner.champion = info.summoner_info.champion;
          }
          if (info.summoner_info.position) {
            updates.summoner.position = info.summoner_info.position;
          }
          if (info.summoner_info.team) {
            updates.summoner.team = info.summoner_info.team;
          }
        }
        
        // Actualizar nivel
        if (info.level) {
          updates.summoner.level = parseInt(info.level) || gameDataManager.currentData.summoner.level;
        }
        
        // Actualizar CS (minions)
        if (info.minions) {
          let cs = gameDataManager.currentData.match.cs;
          if (info.minions.minionKills) {
            cs = parseInt(info.minions.minionKills) || cs;
          }
          if (info.minions.neutralMinionKills) {
            cs += parseInt(info.minions.neutralMinionKills) || 0;
          }
          updates.match.cs = cs;
        }
        
        // Actualizar oro
        if (info.gold) {
          updates.match.gold = parseInt(info.gold) || gameDataManager.currentData.match.gold;
        }
        
        // Actualizar modo de juego
        if (info.gameMode) {
          updates.match.gameMode = info.gameMode;
        }
        
        // Actualizar tiempo de juego
        if (info.counters && info.counters.match_clock) {
          updates.match.gameTime = parseInt(info.counters.match_clock) || gameDataManager.currentData.match.gameTime;
        }
        
        // Actualizar KDA
        if (info.kill && info.kill.kills) {
          updates.match.kills = parseInt(info.kill.kills);
          
          // Registrar evento de kill
          updates.events.push({
            type: 'kill',
            timestamp: Date.now(),
            data: { kills: updates.match.kills }
          });
        }
        
        if (info.death && info.death.deaths) {
          updates.match.deaths = parseInt(info.death.deaths);
          
          // Registrar evento de muerte
          updates.events.push({
            type: 'death',
            timestamp: Date.now(),
            data: { deaths: updates.match.deaths }
          });
        }
        
        if (info.assist && info.assist.assists) {
          updates.match.assists = parseInt(info.assist.assists);
          
          // Registrar evento de asistencia
          updates.events.push({
            type: 'assist',
            timestamp: Date.now(),
            data: { assists: updates.match.assists }
          });
        }
        
        // NUEVO: Procesar estadísticas de equipo
        if (info.teams) {
          try {
            const teams = JSON.parse(info.teams);
            // Encontrar equipo del jugador
            const playerTeam = gameDataManager.currentData.summoner.team;
            if (playerTeam && teams[playerTeam]) {
              updates.teamStats = {
                totalKills: teams[playerTeam].kills || 0,
                totalDeaths: teams[playerTeam].deaths || 0,
                totalObjectives: (teams[playerTeam].objectives || 0)
              };
            }
          } catch (e) {
            console.error("Error al parsear datos de equipos:", e);
          }
        }
        
        // NUEVO: Procesar estadísticas de daño
        if (info.damage) {
          try {
            updates.combat = updates.combat || {};
            updates.combat.damageDealt = parseInt(info.damage.total) || 0;
          } catch (e) {
            console.error("Error al procesar datos de daño:", e);
          }
        }
        
        // NUEVO: Procesar estadísticas de curación
        if (info.heal) {
          try {
            updates.combat = updates.combat || {};
            updates.combat.healing = parseInt(info.heal.total) || 0;
          } catch (e) {
            console.error("Error al procesar datos de curación:", e);
          }
        }
        
        // NUEVO: Procesar wards
        if (info.ward) {
          try {
            updates.vision = updates.vision || {};
            if (info.ward.placed) {
              updates.vision.wardsPlaced = parseInt(info.ward.placed) || 0;
              
              // Registrar evento de ward colocada
              if (updates.vision.wardsPlaced > gameDataManager.currentData.vision.wardsPlaced) {
                updates.events.push({
                  type: 'ward_placed',
                  timestamp: Date.now(),
                  data: { wardsPlaced: updates.vision.wardsPlaced }
                });
              }
            }
            if (info.ward.destroyed) {
              updates.vision.wardsDestroyed = parseInt(info.ward.destroyed) || 0;
            }
          } catch (e) {
            console.error("Error al procesar datos de wards:", e);
          }
        }
        
        // NUEVO: Procesar objetivos
        if (info.objective) {
          try {
            updates.objectives = updates.objectives || {};
            
            // Detectar cambios en objetivos específicos
            const objTypes = {
              'turret': 'turretKills',
              'inhibitor': 'inhibitorKills',
              'dragon': 'dragonKills',
              'baron': 'baronKills',
              'herald': 'heraldKills'
            };
            
            for (const [type, field] of Object.entries(objTypes)) {
              if (info.objective[type]) {
                updates.objectives[field] = parseInt(info.objective[type]) || 0;
                
                // Si ha aumentado, registrar evento
                if (updates.objectives[field] > (gameDataManager.currentData.objectives[field] || 0)) {
                  updates.events.push({
                    type: `${type}_kill`,
                    timestamp: Date.now(),
                    data: { [field]: updates.objectives[field] }
                  });
                }
              }
            }
          } catch (e) {
            console.error("Error al procesar datos de objetivos:", e);
          }
        }
        
        // Procesar datos de live_client_data
        if (info.live_client_data) {
          // Datos del jugador activo
          if (info.live_client_data.active_player) {
            try {
              const player = JSON.parse(info.live_client_data.active_player);
              
              if (player.summonerName) {
                updates.summoner.name = player.summonerName;
              }
              
              if (player.level) {
                updates.summoner.level = player.level;
              }
              
              if (player.championStats) {
                updates.match.gold = Math.round(player.championStats.currentGold || gameDataManager.currentData.match.gold);
              }
              
              // NUEVO: Procesar datos de inventario
              if (player.items) {
                updates.items = updates.items || {};
                updates.items.inventory = player.items.map(item => ({
                  id: item.itemID,
                  name: item.displayName,
                  slot: item.slot
                }));
              }
            } catch (e) {
              console.log("Error al parsear active_player:", e);
            }
          }
          
          // Datos del juego
          if (info.live_client_data.game_data) {
            try {
              const gameInfo = JSON.parse(info.live_client_data.game_data);
              
              if (gameInfo.gameTime) {
                updates.match.gameTime = Math.floor(parseFloat(gameInfo.gameTime));
              }
              
              if (gameInfo.gameMode) {
                updates.match.gameMode = gameInfo.gameMode;
              }
            } catch (e) {
              console.log("Error al parsear game_data:", e);
            }
          }
          
          // Actualizar eventos del juego
          if (info.live_client_data.events) {
            try {
              const events = JSON.parse(info.live_client_data.events);
              
              if (events && events.Events) {
                events.Events.forEach(event => {
                  // Procesar eventos de asesinato
                  if (event.EventName === "ChampionKill") {
                    const playerName = gameDataManager.currentData.summoner.name;
                    
                    if (event.KillerName === playerName) {
                      updates.match.kills = (updates.match.kills !== undefined ? 
                                          updates.match.kills : gameDataManager.currentData.match.kills) + 1;
                                          
                      updates.events.push({
                        type: 'kill',
                        timestamp: Date.now(),
                        data: { 
                          killer: event.KillerName,
                          victim: event.VictimName
                        }
                      });
                    }
                    
                    if (event.VictimName === playerName) {
                      updates.match.deaths = (updates.match.deaths !== undefined ? 
                                           updates.match.deaths : gameDataManager.currentData.match.deaths) + 1;
                                           
                      updates.events.push({
                        type: 'death',
                        timestamp: Date.now(),
                        data: { 
                          killer: event.KillerName,
                          victim: event.VictimName
                        }
                      });
                    }
                    
                    if (event.Assisters && event.Assisters.includes(playerName)) {
                      updates.match.assists = (updates.match.assists !== undefined ? 
                                            updates.match.assists : gameDataManager.currentData.match.assists) + 1;
                                            
                      updates.events.push({
                        type: 'assist',
                        timestamp: Date.now(),
                        data: { 
                          killer: event.KillerName,
                          victim: event.VictimName,
                          assister: playerName
                        }
                      });
                    }
                  }
                  
                  // NUEVO: Procesar eventos de ward
                  else if (event.EventName === "WardPlaced") {
                    if (event.WardType && event.PlacerName === gameDataManager.currentData.summoner.name) {
                      updates.vision = updates.vision || {};
                      updates.vision.wardsPlaced = (updates.vision.wardsPlaced || 
                                                 gameDataManager.currentData.vision.wardsPlaced || 0) + 1;
                                                 
                      if (event.WardType.includes("Control")) {
                        updates.vision.controlWards = (updates.vision.controlWards || 
                                                    gameDataManager.currentData.vision.controlWards || 0) + 1;
                      }
                      
                      updates.events.push({
                        type: 'ward_placed',
                        timestamp: Date.now(),
                        data: { 
                          type: event.WardType,
                          placer: event.PlacerName
                        }
                      });
                    }
                  }
                  
                  // NUEVO: Procesar eventos de objetivos
                  else if (event.EventName === "DragonKill" || 
                         event.EventName === "HeraldKill" || 
                         event.EventName === "BaronKill") {
                    const objectiveType = event.EventName.replace('Kill', '').toLowerCase();
                    const field = `${objectiveType}Kills`;
                    
                    // Si el jugador o su equipo participó
                    const team = gameDataManager.currentData.summoner.team;
                    if (event.KillerName.includes(team)) {
                      updates.objectives = updates.objectives || {};
                      updates.objectives[field] = (updates.objectives[field] || 
                                               gameDataManager.currentData.objectives[field] || 0) + 1;
                                               
                      updates.events.push({
                        type: `${objectiveType}_kill`,
                        timestamp: Date.now(),
                        data: { 
                          team: event.KillerName,
                          type: objectiveType
                        }
                      });
                    }
                  }
                  
                  // NUEVO: Procesar eventos de torreta
                  else if (event.EventName === "TurretKilled") {
                    const playerName = gameDataManager.currentData.summoner.name;
                    const field = 'turretKills';
                    
                    if (event.KillerName === playerName || 
                        (event.Assisters && event.Assisters.includes(playerName))) {
                      updates.objectives = updates.objectives || {};
                      updates.objectives[field] = (updates.objectives[field] || 
                                               gameDataManager.currentData.objectives[field] || 0) + 1;
                                               
                      updates.events.push({
                        type: 'turret_kill',
                        timestamp: Date.now(),
                        data: { 
                          killer: event.KillerName,
                          assisters: event.Assisters
                        }
                      });
                    }
                  }
                  
                  // Añadir el evento al registro general
                  updates.events.push({
                    type: 'game_event',
                    name: event.EventName,
                    timestamp: Date.now(),
                    data: event
                  });
                });
              }
            } catch (e) {
              console.log("Error al parsear eventos:", e);
            }
          }
        }
        
        // Actualizar datos centralizados si hay cambios
        if (Object.keys(updates.summoner).length > 0 || 
            Object.keys(updates.match).length > 0 || 
            Object.keys(updates.combat).length > 0 || 
            Object.keys(updates.vision).length > 0 || 
            Object.keys(updates.objectives).length > 0 || 
            Object.keys(updates.items).length > 0 || 
            Object.keys(updates.teamStats).length > 0 || 
            updates.events.length > 0) {
          gameDataManager.updateData(updates);
          
          // Forzar actualización directa de la pestaña
          forceUpdateOverviewTab();
        }
      } catch (e) {
        console.error("Error procesando datos:", e);
      }
    }
    
    // Manejar nuevos eventos
    function onNewEvents(e) {
      const isHighlight = e.events && e.events.some(event => 
        ['kill', 'death', 'assist', 'level', 'matchStart', 'matchEnd'].includes(event.name)
      );
      
      addToLog(eventsLog, e, isHighlight);
      
      if (e.events) {
        const updates = {
          summoner: {},
          match: {},
          objectives: {},
          events: []
        };
        
        e.events.forEach(event => {
          updates.events.push({
            name: event.name,
            data: event.data,
            timestamp: new Date().getTime()
          });
          
          switch (event.name) {
            case 'kill':
              updates.match.kills = gameDataManager.currentData.match.kills + 1;
              break;
            case 'death':
              updates.match.deaths = gameDataManager.currentData.match.deaths + 1;
              break;
            case 'assist':
              updates.match.assists = gameDataManager.currentData.match.assists + 1;
              break;
            case 'level':
              if (event.data && event.data.level) {
                updates.summoner.level = parseInt(event.data.level);
              }
              break;
            case 'matchStart':
              updates.match.kills = 0;
              updates.match.deaths = 0;
              updates.match.assists = 0;
              updates.match.cs = 0;
              break;
          }
        });
        
        gameDataManager.updateData(updates);
      }
    }
    
    // Registrar manejadores de eventos
    function registerEvents() {
      unregisterEvents();
      
      overwolf.games.events.onError.addListener(onError);
      overwolf.games.events.onInfoUpdates2.addListener(onInfoUpdates);
      overwolf.games.events.onNewEvents.addListener(onNewEvents);
      
      console.log("Eventos registrados directamente en in_game.html");
    }
    
    // Eliminar manejadores de eventos
    function unregisterEvents() {
      try {
        overwolf.games.events.onError.removeListener(onError);
        overwolf.games.events.onInfoUpdates2.removeListener(onInfoUpdates);
        overwolf.games.events.onNewEvents.removeListener(onNewEvents);
      } catch (e) {
        console.log("Error al eliminar listeners:", e);
      }
    }
    
    // Configurar características requeridas
    function setFeatures() {
      console.log("Intentando establecer características:", features);
      
      overwolf.games.events.setRequiredFeatures(features, function(info) {
        if (!info.success) {
          console.log("No se pudieron establecer las características:", info.error);
          setTimeout(setFeatures, 2000);
          return;
        }
        
        console.log("Características establecidas correctamente");
      });
    }
    
    // Función para obtener datos de la API Live Client de LoL
    function fetchLiveClientData() {
      console.log("Obteniendo datos de Live Client Data API...");
      
      fetch('https://127.0.0.1:2999/liveclientdata/allgamedata')
        .then(response => {
          if (!response.ok) {
            throw new Error(`Error HTTP: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          console.log("Datos obtenidos de API:", data);
          
          const updates = {
            summoner: {},
            match: {}
          };
          
          if (data && data.activePlayer) {
            if (data.activePlayer.summonerName) {
              updates.summoner.name = data.activePlayer.summonerName;
            }
            
            if (data.activePlayer.level) {
              updates.summoner.level = data.activePlayer.level;
            }
            
            if (data.allPlayers) {
              const activePlayerData = data.allPlayers.find(p => 
                p.summonerName === data.activePlayer.summonerName
              );
              
              if (activePlayerData) {
                updates.summoner.champion = activePlayerData.championName || '';
                
                if (activePlayerData.scores) {
                  updates.match.kills = activePlayerData.scores.kills || 0;
                  updates.match.deaths = activePlayerData.scores.deaths || 0;
                  updates.match.assists = activePlayerData.scores.assists || 0;
                  updates.match.cs = 
                    (activePlayerData.scores.creepScore || 0) + 
                    (activePlayerData.scores.neutralMinionsKilled || 0);
                  updates.match.gold = Math.round(activePlayerData.scores.currentGold || 0);
                }
              }
            }
            
            if (data.gameData && data.gameData.gameTime) {
              updates.match.gameTime = Math.floor(data.gameData.gameTime);
            }
            
            if (data.gameData && data.gameData.gameMode) {
              updates.match.gameMode = data.gameData.gameMode;
            }
            
            gameDataManager.updateData(updates);
          }
        })
        .catch(error => {
          console.error("Error API:", error);
        });
    }
    
    // Manejar cambios en el estado del juego
    function handleGameStateChange(gameInfo) {
      if (gameInfo && gameInfo.isRunning && Math.floor(gameInfo.id/10) === 5426) {
        console.log("LoL detectado. Iniciando captura de eventos...");
        
        registerEvents();
        setTimeout(setFeatures, 1000);
        
        fetchLiveClientData();
        // Aumentar la frecuencia de actualización de datos
        window.lolDataInterval = setInterval(fetchLiveClientData, 1000);
        
        // NUEVO: Crear un intervalo específico para forzar actualizaciones de UI
        if (!window.uiUpdateInterval) {
          window.uiUpdateInterval = setInterval(function() {
            // Forzar actualizaciones más frecuentes (cada 1 segundo)
            const activeTab = document.querySelector('.tabs__pane--active');
            if (activeTab) {
              window.updateTabWithGameData(activeTab.id);
            }
            
            // Mostrar datos actuales como verificación
            console.log("Estado actual de gameDataManager:", {
              summoner: gameDataManager.currentData.summoner.name,
              gameTime: gameDataManager.currentData.match.gameTime,
              kda: `${gameDataManager.currentData.match.kills}/${gameDataManager.currentData.match.deaths}/${gameDataManager.currentData.match.assists}`
            });
          }, 1000);
        }
      } else {
        console.log("LoL no detectado o cerrado.");
        unregisterEvents();
        
        if (window.lolDataInterval) {
          clearInterval(window.lolDataInterval);
          window.lolDataInterval = null;
        }
        
        // NUEVO: Limpiar también el intervalo de actualizaciones de UI
        if (window.uiUpdateInterval) {
          clearInterval(window.uiUpdateInterval);
          window.uiUpdateInterval = null;
        }
      }
    }
    
    // Verificar estado actual del juego
    overwolf.games.getRunningGameInfo(function(gameInfo) {
      if (gameInfo) {
        handleGameStateChange(gameInfo);
      }
    });
    
    // Escuchar cambios en el estado del juego
    overwolf.games.onGameInfoUpdated.addListener(function(res) {
      if (res && res.gameInfo) {
        handleGameStateChange(res.gameInfo);
      }
    });
    
    // Exponer métodos para las pestañas
    window.gameDataManager = gameDataManager;
    
    window.getGameData = function() {
      return gameDataManager.getData();
    };
    
    window.subscribeToGameData = function(callback) {
      console.log('window.subscribeToGameData: Nuevo intento de suscripción');
      return window.gameDataManager.subscribe(callback);
    };
    
    // NUEVO: Función auxiliar para actualizar una pestaña específica
    window.updateTabWithGameData = function(tabId) {
      try {
        console.log(`Intentando actualizar manualmente la pestaña ${tabId} con datos actuales`);
        const tabPane = document.getElementById(tabId);
        
        if (!tabPane) {
          console.error(`No se encontró la pestaña con ID ${tabId}`);
          return false;
        }
        
        const data = gameDataManager.getData();
        
        // Buscar la función updateUI dentro del contenido de la pestaña
        const updateUIFn = tabPane.querySelector('script')?.textContent.includes('function updateUI') 
          ? new Function('return ' + tabPane.querySelector('script')?.textContent)().updateUI 
          : null;
        
        if (updateUIFn) {
          console.log(`Se encontró updateUI en la pestaña ${tabId}, llamándola...`);
          try {
            updateUIFn(data);
            return true;
          } catch (e) {
            console.error(`Error al llamar a updateUI en ${tabId}:`, e);
          }
        } else {
          console.error(`No se encontró la función updateUI en la pestaña ${tabId}`);
          
          // Intento alternativo - buscar elementos directamente
          const playerNameElement = tabPane.querySelector('#player-name');
          const gameTimeElement = tabPane.querySelector('#game-time-value');
          const killsElement = tabPane.querySelector('#kda-kills');
          const deathsElement = tabPane.querySelector('#kda-deaths');
          const assistsElement = tabPane.querySelector('#kda-assists');
          
          let updated = false;
          
          if (playerNameElement && data.summoner && data.summoner.name) {
            playerNameElement.textContent = data.summoner.name;
            updated = true;
          }
          
          if (gameTimeElement && data.match && data.match.gameTime !== undefined) {
            gameTimeElement.textContent = formatGameTime(data.match.gameTime);
            updated = true;
          }
          
          if (killsElement && data.match) {
            killsElement.textContent = data.match.kills || '0';
            updated = true;
          }
          
          if (deathsElement && data.match) {
            deathsElement.textContent = data.match.deaths || '0';
            updated = true;
          }
          
          if (assistsElement && data.match) {
            assistsElement.textContent = data.match.assists || '0';
            updated = true;
          }
          
          return updated;
        }
      } catch (e) {
        console.error(`Error general al actualizar la pestaña ${tabId}:`, e);
        return false;
      }
    };
    
    // Listener para recibir mensajes de actualización de datos
    window.addEventListener('message', function(event) {
      console.log('in_game: Mensaje recibido:', event.data);
      
      // Comprobar si es un mensaje de actualización de datos
      if (event.data && event.data.type === 'game_data_update') {
        const dataChanged = window.gameDataManager.updateData(event.data.data);
        console.log('in_game: Datos actualizados:', dataChanged);
      }
    });
    
    // NUEVO: Configurar un intervalo para forzar la actualización de las pestañas
    setInterval(function() {
      // Obtener la pestaña activa
      const activeTab = document.querySelector('.tabs__pane--active');
      if (activeTab) {
        console.log(`Forzando actualización periódica de la pestaña activa: ${activeTab.id}`);
        window.updateTabWithGameData(activeTab.id);
      }
    }, 2000); // Cada 2 segundos
    
    // Método para propagar datos globalmente (para debugging)
    window.debugGameData = function() {
      console.log('gameDataManager estado actual:', window.gameDataManager);
      return {
        subscribers: window.gameDataManager.listeners.length,
        data: {
          summoner: { ...window.gameDataManager.summoner },
          match: { ...window.gameDataManager.match }
        }
      };
    };
    
    // NUEVO: Función para actualizar forzadamente la pestaña de resumen
    function forceUpdateOverviewTab() {
      console.log("Forzando actualización de la pestaña de resumen");
      
      // Verificar si tenemos datos válidos
      if (!gameDataManager.currentData.summoner.name) {
        console.log("No hay datos de jugador todavía, no actualizamos");
        return;
      }
      
      // Buscar la pestaña de resumen
      const overviewTab = document.getElementById('overview-tab');
      if (!overviewTab) {
        console.log("Pestaña de resumen no encontrada");
        return;
      }
      
      // Buscar los elementos dentro de la pestaña
      const playerNameElement = overviewTab.querySelector('#player-name');
      const gameTimeElement = overviewTab.querySelector('#game-time-value');
      const killsElement = overviewTab.querySelector('#kda-kills');
      const deathsElement = overviewTab.querySelector('#kda-deaths');
      const assistsElement = overviewTab.querySelector('#kda-assists');
      
      // Intentar actualizar directamente los elementos
      try {
        // Actualizar nombre
        if (playerNameElement) {
          playerNameElement.textContent = gameDataManager.currentData.summoner.name || "Desconocido";
          console.log("Nombre actualizado a:", gameDataManager.currentData.summoner.name);
        }
        
        // Actualizar tiempo
        if (gameTimeElement) {
          const formattedTime = formatGameTime(gameDataManager.currentData.match.gameTime);
          gameTimeElement.textContent = formattedTime;
          console.log("Tiempo actualizado a:", formattedTime);
        }
        
        // Actualizar KDA
        if (killsElement) {
          killsElement.textContent = gameDataManager.currentData.match.kills || "0";
        }
        if (deathsElement) {
          deathsElement.textContent = gameDataManager.currentData.match.deaths || "0";
        }
        if (assistsElement) {
          assistsElement.textContent = gameDataManager.currentData.match.assists || "0";
        }
        
        console.log("Actualización directa completada");
        
        // Intentar ejecutar updateUI si existe
        try {
          const script = document.createElement('script');
          script.textContent = `
            try {
              if (typeof window.frames[0].updateUI === 'function') {
                window.frames[0].updateUI(${JSON.stringify(gameDataManager.currentData)});
                console.log("updateUI ejecutado en frame");
              } else if (typeof window.updateUI === 'function') {
                window.updateUI(${JSON.stringify(gameDataManager.currentData)});
                console.log("updateUI ejecutado en ventana principal");
              } else {
                console.log("updateUI no encontrada");
              }
            } catch(e) {
              console.error("Error ejecutando updateUI:", e);
            }
          `;
          document.body.appendChild(script);
        } catch (e) {
          console.error("Error al ejecutar script:", e);
        }
      } catch (e) {
        console.error("Error actualizando elementos:", e);
      }
    }
    
    // Llamar periódicamente a la función de actualización forzada
    setInterval(forceUpdateOverviewTab, 1000);
    
    console.log('Sistema integrado de captura de eventos y gestión de datos inicializado. Versión: 2.0');
  </script>

  <style>
    /* Ocultar elementos no deseados */
    .overwolf-events-header, .overwolf-events-container {
      display: none !important;
    }
    
    /* Evitar scrolls innecesarios */
    body {
      overflow: hidden;
    }
    
    /* Mejorar scrolls en pestañas */
    .tabs__content, .tabs__pane {
      overflow-x: hidden !important;
    }
    
    /* Eliminar scroll horizontal en contenedor principal */
    .main-content-wrapper {
      overflow-x: hidden !important;
    }
  </style>
</body>
</html>